import supplierOrdersData from '@/services/mockData/supplierOrders.json';
import deviceService from '@/services/api/deviceService';
import saleService from '@/services/api/saleService';
import supplierService from '@/services/api/supplierService';

let supplierOrders = [...supplierOrdersData];
let nextId = Math.max(...supplierOrders.map(o => o.Id), 0) + 1;

const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const dismissedSuggestions = new Set();

const supplierOrderService = {
  async getAll() {
    await delay(300);
    return supplierOrders.map(order => ({
      ...order,
      items: [...order.items]
    }));
  },

  async getById(id) {
    await delay(200);
    const order = supplierOrders.find(o => o.Id === parseInt(id));
    if (!order) {
      throw new Error('Supplier order not found');
    }
    return {
      ...order,
      items: [...order.items]
    };
  },

  async create(orderData) {
    await delay(400);
    const newOrder = {
      Id: nextId++,
      supplierId: orderData.supplierId,
      orderDate: new Date().toISOString(),
      expectedDelivery: orderData.expectedDelivery,
      status: 'Pending',
      items: orderData.items.map(item => ({
        deviceId: item.deviceId,
        quantity: item.quantity,
        unitCost: item.unitCost
      })),
      totalCost: orderData.items.reduce((sum, item) => sum + (item.quantity * item.unitCost), 0),
      notes: orderData.notes || '',
      autoGenerated: orderData.autoGenerated || false
    };
    supplierOrders.push(newOrder);
    return { ...newOrder };
  },

  async update(id, updates) {
    await delay(400);
    const index = supplierOrders.findIndex(o => o.Id === parseInt(id));
    if (index === -1) {
      throw new Error('Supplier order not found');
    }

    const updatedOrder = {
      ...supplierOrders[index],
      ...updates,
      Id: supplierOrders[index].Id,
      orderDate: supplierOrders[index].orderDate
    };

    if (updates.items) {
      updatedOrder.totalCost = updates.items.reduce(
        (sum, item) => sum + (item.quantity * item.unitCost), 
        0
      );
    }

    supplierOrders[index] = updatedOrder;
    return { ...updatedOrder };
  },

  async delete(id) {
    await delay(300);
    const index = supplierOrders.findIndex(o => o.Id === parseInt(id));
    if (index === -1) {
      throw new Error('Supplier order not found');
    }
    supplierOrders.splice(index, 1);
    return { success: true };
  },

  async getSuggestedItems() {
    await delay(500);
    
    const devices = await deviceService.getAll();
    const currentStock = await deviceService.getCurrentStock();
    const salesVelocity = await saleService.getSalesVelocity();
    
    const suggestions = devices.map(device => {
      const stock = currentStock[device.Id] || 0;
      const velocity = salesVelocity[device.Id] || 0;
      
      const daysOfStock = velocity > 0 ? stock / velocity : 999;
      const suggestedQuantity = Math.max(0, Math.ceil(velocity * 30) - stock);
      
      const priority = velocity > 0 && daysOfStock < 14 ? 'high' : 
                      velocity > 0 && daysOfStock < 30 ? 'medium' : 'low';
      
      return {
        deviceId: device.Id,
        deviceName: device.name,
        brand: device.brand,
        model: device.model,
        currentStock: stock,
        salesVelocity: velocity,
        daysOfStock: Math.round(daysOfStock),
        suggestedQuantity,
        estimatedCost: device.cost,
        priority,
        needsReorder: daysOfStock < 30 && velocity > 0
      };
    });

    return suggestions
      .filter(s => s.needsReorder)
      .sort((a, b) => {
        if (a.priority !== b.priority) {
          const priorityOrder = { high: 0, medium: 1, low: 2 };
          return priorityOrder[a.priority] - priorityOrder[b.priority];
        }
        return a.daysOfStock - b.daysOfStock;
      });
  },

  async getAutoGeneratedOrders() {
    await delay(400);
    
    const devices = await deviceService.getAll();
    const suppliers = await supplierService.getAll();
    
    const suggestions = [];
    
    for (const device of devices) {
      if (dismissedSuggestions.has(device.Id)) {
        continue;
      }
      
      if (device.quantity < device.lowStockThreshold) {
        const salesVelocity = Math.random() * 2 + 0.5;
        const daysOfStock = device.quantity / salesVelocity;
        const suggestedQuantity = Math.max(
          device.lowStockThreshold * 2,
          Math.ceil(salesVelocity * 30) - device.quantity
        );
        
        const priority = daysOfStock < 7 ? 'high' : 
                        daysOfStock < 14 ? 'medium' : 'low';
        
        const supplier = suppliers.find(s => s.supplierId === device.supplierId);
        
        suggestions.push({
          deviceId: device.Id,
          deviceName: `${device.brand} ${device.model}`,
          brand: device.brand,
          model: device.model,
          currentStock: device.quantity,
          salesVelocity: parseFloat(salesVelocity.toFixed(2)),
          daysOfStock: Math.round(daysOfStock),
          suggestedQuantity,
          estimatedCost: device.purchasePrice,
          priority,
          supplierId: supplier?.Id || 1,
          supplierName: supplier?.name || 'Unknown Supplier'
        });
      }
    }
    
    return suggestions.sort((a, b) => {
      if (a.priority !== b.priority) {
        const priorityOrder = { high: 0, medium: 1, low: 2 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
      }
      return a.daysOfStock - b.daysOfStock;
    });
  },

  async approveSuggestedOrder(suggestion) {
    await delay(300);
    
    const expectedDelivery = new Date();
    expectedDelivery.setDate(expectedDelivery.getDate() + 7);
    
    const orderData = {
      supplierId: suggestion.supplierId,
      expectedDelivery: expectedDelivery.toISOString(),
      items: [{
        deviceId: suggestion.deviceId,
        quantity: suggestion.suggestedQuantity,
        unitCost: suggestion.estimatedCost
      }],
      notes: `Auto-generated order - ${suggestion.priority} priority restock`,
      autoGenerated: true
    };
    
    dismissedSuggestions.add(suggestion.deviceId);
    
    return await this.create(orderData);
  },

  async dismissSuggestion(deviceId) {
    await delay(200);
    dismissedSuggestions.add(deviceId);
    return { success: true };
  },

  async getSupplierPerformance() {
    await delay(500);
    
    const suppliers = await supplierService.getAll();
    const orders = supplierOrders.filter(o => o.status === 'Received' || o.status === 'Ordered');
    
    return suppliers.map(supplier => {
      const supplierOrders = orders.filter(o => o.supplierId === supplier.Id);
      const completedOrders = supplierOrders.filter(o => o.status === 'Received');
      
      let totalDeliveryDays = 0;
      let onTimeDeliveries = 0;
      
      completedOrders.forEach(order => {
        const orderDate = new Date(order.orderDate);
        const expectedDate = new Date(order.expectedDelivery);
        const actualDeliveryDate = new Date(order.orderDate);
        actualDeliveryDate.setDate(actualDeliveryDate.getDate() + Math.floor(Math.random() * 10) + 3);
        
        const deliveryDays = Math.floor((actualDeliveryDate - orderDate) / (1000 * 60 * 60 * 24));
        totalDeliveryDays += deliveryDays;
        
        if (actualDeliveryDate <= expectedDate) {
          onTimeDeliveries++;
        }
      });
      
      const avgDeliveryDays = completedOrders.length > 0 
        ? totalDeliveryDays / completedOrders.length 
        : 0;
      
      const onTimeDeliveryRate = completedOrders.length > 0
        ? (onTimeDeliveries / completedOrders.length) * 100
        : 0;
      
      const orderCompletionRate = supplierOrders.length > 0
        ? (completedOrders.length / supplierOrders.length) * 100
        : 0;
      
      return {
        supplierId: supplier.Id,
        supplierName: supplier.name,
        totalOrders: supplierOrders.length,
        completedOrders: completedOrders.length,
        avgDeliveryDays: parseFloat(avgDeliveryDays.toFixed(1)),
        onTimeDeliveryRate: parseFloat(onTimeDeliveryRate.toFixed(1)),
        orderCompletionRate: parseFloat(orderCompletionRate.toFixed(1))
      };
    }).filter(p => p.totalOrders > 0);
  }
};

export default supplierOrderService;